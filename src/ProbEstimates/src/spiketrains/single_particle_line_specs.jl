### Line Specs for a single trace generated by importance sampling ###

"""
    abstract type SingleParticleLineSpec <: LineSpec end

A `SingleParticleLineSpec` specifies the information in a line in a Spiketrain.  E.g.
this might specify a line of text to insert into the spiketrain, or the type of value conveyed
by a line of spikes (e.g. a discrete variable taking a value, or a dense-coded value, etc.)
"""
abstract type SingleParticleLineSpec <: LineSpec end

"""
Given a list `specs` of `SingleParticleLineSpec`s and a `tr` where `get_submap(get_choices(tr), nest_all_at)`
was produced by an importance-sampling simulation in NG-F, this
produces spiketrains consistent with the NG-F simulation, and returns a vector giving
the spiketrain-line value for each spec in `specs`.

`spiketrain_data_args` should specify the arguments after `tr` to pass to
`sample_is_spiketimes_for_trace` (which is used to get spiketrains for the IS run).
"""
function get_lines(specs, tr, spiketrain_data_args; nest_all_at=nothing)
    spiketrain_data =
        if any(spec isa SpiketrainSpec for spec in specs)
            sample_is_spiketimes_for_trace(tr, spiketrain_data_args...; nest_all_at)
        else
            nothing
        end

    return [get_line(spec, tr, spiketrain_data; nest_all_at) for spec in specs]
end
get_labels(lines) = map(get_label, lines)

get_line(spec::LineSpec, tr; nest_all_at=nothing) = get_line(spec, tr, nothing; nest_all_at)

### Text-Related Line Specs (ie. lines of text for different values in spiketrains) ###
abstract type SingleParticleText <: SingleParticleLineSpec; end
struct SampledValue <: SingleParticleText; addr; name; end
struct FwdScoreText <: SingleParticleText; addr; name; end
struct RecipScoreText <: SingleParticleText; addr; name; end
SampledValue(a) = SampledValue(a, a)
FwdScoreText(a) = FwdScoreText(a, a)
RecipScoreText(a) = RecipScoreText(a, a)

get_line(spec::SampledValue, tr, a; nest_all_at) = "$(spec.name)=$(tr[nest(nest_all_at, spec.addr)])"
get_line(spec::FwdScoreText, tr, a; nest_all_at) = "P[$(spec.name)] ≈ $(round(get_fwd_score(get_ch(tr, nest_all_at), spec.addr); digits=2))"
get_line(spec::RecipScoreText, tr, a; nest_all_at) = "1/Q[$(spec.name)] ≈ $(round(get_recip_score(get_ch(tr, nest_all_at), spec.addr), digits=2))"

get_ch(tr, nest_at) = isnothing(nest_at) ? get_choices(tr) : get_submap(get_choices(tr), nest_at)
# get_label(spec::SampledValue) = "$(spec.addr) = "
# get_label(spec::FwdScoreText) = "P[$(spec.addr) ; Pa($(spec.addr))] ≈"
# get_label(spec::RecipScoreText) = "1/Q[$(spec.addr) ; Pa($(spec.addr))] ≈"
get_label(::SingleParticleText) = ""

get_fwd_score(ch, addr) = ch[nest(addr, :fwd_score)]
get_recip_score(ch, addr) =
    try
        ch[nest(addr, :recip_score)]
    catch e
        println("Failed to get recip score; nesting addr = $addr ; ch = ")
        display(ch)
        throw(e)
    end

### Spiketrain line specs ###
"""
    SpiketrainSpec <: LineSpec

Specifies a line in a spiketrain visualization which is a spiketrain (ie. a line of spikes
occurring at different times).
"""
abstract type SpiketrainSpec <: LineSpec; end
"""
    VarValLine

Spiketrain for the "neuron" describing a discrete variable taking a particular value.
"""
struct VarValLine <: SpiketrainSpec; addr; value; end

"""
    ScoreLine

Spiketrain within a direct or reciprocal probability estimate.  (The particular spiketrain for this score is described by `line_to_show`.)
"""
struct ScoreLine <: SpiketrainSpec
    do_recip_score::Bool # alternatively do fwd
    addr
    line_to_show::SpikelineInScore
end
RecipScoreLine(addr, line_to_show) = ScoreLine(true, addr, line_to_show)
FwdScoreLine(addr, line_to_show) = ScoreLine(false, addr, line_to_show)

get_line(spec::VarValLine, tr, trains; nest_all_at) = 
    try
        # if spec.addr == :yᵈₜ
        #     println("tr[nest(nest_all_at, spec.addr)] = $(tr[nest(nest_all_at, spec.addr)]) ; spec.value = $(spec.value); $(trains.val_trains[spec.addr])")
        # end
        tr[nest(nest_all_at, spec.addr)] == spec.value ? trains.val_trains[spec.addr] : []
    catch e
        display(get_submap(get_choices(tr), nest_all_at))
        println(get_submap(get_choices(tr), nest(nest_all_at, spec.addr)))
        println("traceval: ", tr[nest(nest_all_at, spec.addr)])
        display(keys(trains.val_trains))
        println("trains: $(trains.val_trains[spec.addr])")
        @error "Error looking up $(nest(nest_all_at, spec.addr)) in trace." exception=(e, catch_backtrace())
        error()
    end

get_line(spec::ScoreLine, tr, trains; nest_all_at) = get_score_line(spec.line_to_show, (spec.do_recip_score ? trains.recip_trains : trains.fwd_trains)[spec.addr])
get_score_line(::IndLine, trains::DenseValueSpiketrain) = [trains.ready_time]
get_score_line(::CountAssembly, trains::DenseValueSpiketrain) = sort(reduce(vcat, trains.neuron_times))
get_score_line(n::NeuronInCountAssembly, trains::DenseValueSpiketrain) = trains.neuron_times[n.idx]

get_label(spec::VarValLine) = "$(spec.addr)=$(spec.value)"
function get_label(spec::ScoreLine)
    val_label = spec.do_recip_score ? "1/Q[$(spec.addr) ; Pa($(spec.addr))]" : "P[$(spec.addr) ; Pa($(spec.addr))]"
    if spec.line_to_show isa IndLine
        return "$val_label ready"
    elseif spec.line_to_show isa CountAssembly
        return "$val_label count"
    elseif spec.line_to_show isa NeuronInCountAssembly
        return "$val_label count - neuron $(spec.line_to_show.idx)"
    end
end

###
struct DistLine <: SpiketrainSpec
    is_p::Bool
    addr
    value
    line_to_show::SpikelineInScore
end
PDistLine(args...) = DistLine(true, args...)
QDistLine(args...) = DistLine(false, args...)
function get_line(spec::DistLine, tr, trains; nest_all_at)
    neuron_times = (spec.is_p ? trains.p_dist_trains : trains.q_dist_trains)[spec.addr][spec.value]
    return get_dist_line(spec.line_to_show, neuron_times)
end
get_dist_line(::CountAssembly, neuron_times) = sort(reduce(vcat, neuron_times))
get_dist_line(n::NeuronInCountAssembly, neuron_times) = neuron_times[n.idx]