### Line Specs for a single trace generated by importance sampling ###

"""
    abstract type LineSpec end

A `LineSpec` specifies the information in a line in a Spiketrain.  E.g.
this might specify a line of text to insert into the spiketrain, or the type of value conveyed
by a line of spikes (e.g. a discrete variable taking a value, or a dense-coded value, etc.)
"""
abstract type LineSpec end

"""
Given a list `specs` of `LineSpec`s and a `tr` where `get_submap(get_choices(tr), nest_all_at)`
was produced by an importance-sampling simulation in NG-F, this
produces spiketrains consistent with the NG-F simulation, and returns a vector giving
the spiketrain-line value for each spec in `specs`.

`spiketrain_data_args` should specify the arguments after `tr` to pass to
`sample_is_spiketimes_for_trace` (which is used to get spiketrains for the IS run).
"""
function get_lines(specs, tr, spiketrain_data_args; nest_all_at=nothing)
    spiketrain_data =
        if any(spec isa SpiketrainSpec for spec in specs)
            sample_is_spiketimes_for_trace(tr, spiketrain_data_args...; nest_all_at)
        else
            nothing
        end

    return [get_line(spec, tr, spiketrain_data; nest_all_at) for spec in specs]
end
get_labels(lines) = map(get_label, lines)

get_line(spec::LineSpec, tr; nest_all_at=nothing) = get_line(spec, tr, nothing; nest_all_at)

### Text-Related Line Specs (ie. lines of text for different values in spiketrains) ###
abstract type Text <: LineSpec; end
struct SampledValue <: Text; addr; name; end
struct FwdScoreText <: Text; addr; name; end
struct RecipScoreText <: Text; addr; name; end
SampledValue(a) = SampledValue(a, a)
FwdScoreText(a) = FwdScoreText(a, a)
RecipScoreText(a) = RecipScoreText(a, a)

get_line(spec::SampledValue, tr, a; nest_all_at) = "$(spec.name)=$(tr[nest(nest_all_at, spec.addr)])"
get_line(spec::FwdScoreText, tr, a; nest_all_at) = "P[$(spec.name)] ≈ $(round(get_fwd_score(get_ch(tr, nest_all_at), spec.addr); digits=2))"
get_line(spec::RecipScoreText, tr, a; nest_all_at) = "1/Q[$(spec.name)] ≈ $(round(get_recip_score(get_ch(tr, nest_all_at), spec.addr), digits=2))"

get_ch(tr, nest_at) = isnothing(nest_at) ? get_choices(tr) : get_submap(get_choices(tr), nest_at)
# get_label(spec::SampledValue) = "$(spec.addr) = "
# get_label(spec::FwdScoreText) = "P[$(spec.addr) ; Pa($(spec.addr))] ≈"
# get_label(spec::RecipScoreText) = "1/Q[$(spec.addr) ; Pa($(spec.addr))] ≈"
get_label(::Text) = ""

get_fwd_score(ch, addr) = ch[nest(addr, :fwd_score)]
get_recip_score(ch, addr) = ch[nest(addr, :recip_score)]

### Spiketrain line specs ###
"""
    SpiketrainSpec <: LineSpec

Specifies a line in a spiketrain visualization which is a spiketrain (ie. a line of spikes
occurring at different times).
"""
abstract type SpiketrainSpec <: LineSpec; end
"""
    VarValLine

Spiketrain for the "neuron" describing a discrete variable taking a particular value.
"""
struct VarValLine <: SpiketrainSpec; addr; value; end

"""
    ScoreLine

Spiketrain within a direct or reciprocal probability estimate.  (The particular spiketrain for this score is described by `line_to_show`.)
"""
struct ScoreLine <: SpiketrainSpec
    do_recip_score::Bool # alternatively do fwd
    addr
    line_to_show::SpikelineInScore
end
RecipScoreLine(addr, line_to_show) = ScoreLine(true, addr, line_to_show)
FwdScoreLine(addr, line_to_show) = ScoreLine(false, addr, line_to_show)

get_line(spec::VarValLine, tr, trains; nest_all_at) = 
    try
        if spec.addr == :yᵈₜ
            println("tr[nest(nest_all_at, spec.addr)] = $(tr[nest(nest_all_at, spec.addr)]) ; spec.value = $(spec.value); $(trains.val_trains[spec.addr])")
        end
        tr[nest(nest_all_at, spec.addr)] == spec.value ? trains.val_trains[spec.addr] : []
    catch e
        display(get_submap(get_choices(tr), nest_all_at))
        println(get_submap(get_choices(tr), nest(nest_all_at, spec.addr)))
        println("traceval: ", tr[nest(nest_all_at, spec.addr)])
        display(keys(trains.val_trains))
        println("trains: $(trains.val_trains[spec.addr])")
        @error "Error looking up $(nest(nest_all_at, spec.addr)) in trace." exception=(e, catch_backtrace())
        error()
    end

get_line(spec::ScoreLine, tr, trains; nest_all_at) = get_score_line(spec.line_to_show, (spec.do_recip_score ? trains.recip_trains : trains.fwd_trains)[spec.addr])
get_score_line(::IndLine, trains::DenseValueSpiketrain) = [trains.ready_time]
get_score_line(::CountAssembly, trains::DenseValueSpiketrain) = sort(reduce(vcat, trains.neuron_times))
get_score_line(n::NeuronInCountAssembly, trains::DenseValueSpiketrain) = trains.neuron_times[n.idx]

get_label(spec::VarValLine) = "$(spec.addr)=$(spec.value)"
function get_label(spec::ScoreLine)
    val_label = spec.do_recip_score ? "1/Q[$(spec.addr) ; Pa($(spec.addr))]" : "P[$(spec.addr) ; Pa($(spec.addr))]"
    if spec.line_to_show isa IndLine
        return "$val_label ready"
    elseif spec.line_to_show isa CountAssembly
        return "$val_label count"
    elseif spec.line_to_show isa NeuronInCountAssembly
        return "$val_label count - neuron $(spec.line_to_show.idx)"
    end
end

### Grouped Line Specs ###
"""
A LabeledLineGroup describes a collection of lines in a spiketrain which
should all share a label.  (E.g. this might be used when showing
multiple lines used to convey a single value, to label all those lines
with the name of that value.)
"""
struct LabeledLineGroup
    label_spec::Text
    line_specs::Vector{LineSpec}
end
get_lines(groups::Vector{LabeledLineGroup}, tr, args; nest_all_at=nothing) =
    get_lines(reduce(vcat, g.line_specs for g in groups), tr, args; nest_all_at)
get_labels(groups::Vector{LabeledLineGroup}) = get_labels(reduce(vcat, g.line_specs for g in groups))

get_group_labels(groups::Vector{LabeledLineGroup}, tr; nest_all_at) =
    [ # list of (label, num lines in group) tuples for each group
        (get_line(g.label_spec, tr, nothing; nest_all_at), length(g.line_specs))
        for g in groups
    ]

get_group_label(group::LabeledLineGroup, tr) = get_line(group.label_spec, tr)